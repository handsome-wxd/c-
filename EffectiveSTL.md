[toc]

# 使用STL库的55条建议

## 1.慎重选择容器的类型

根据你的业务需求和算法去选择不同的容器，将数据结构和算法结合起来。

c++容器类型：

- 序列容器：其中对象有序排列，根据整数值进行索引,有vector,list,deque,string
- 关联容器：其中对象的顺序不重要，根据键值进行索引,set,map,multiset,multimap
- 适配器：调正原有容器的行为，使对外产生新的接口，类型和返回元素。
- 生成器：构造元素序列

标准容器:指的是c++标准化后的容器，遵从c++的标准，不同的编译器都支持，代码移植能力强。vector,list,deque,string，set,map,multiset,multimap

非标准容器:指的是违背标准化后的容器，在不同版本的编译器上可能不支持,hash_set,hast_map等等

使用参考：

例如需要按顺序插入元素就需要序列容器，如果元素的顺序不重要就使用关联容器，如果就频繁删除容器内元素就避免使用内存连续的容器

## 2.不要试图编写独立于容器的代码

因为不同的容器所支持的函数和迭代器类型使不同的，可能会报错，所以不要编写独立于容器的代码。

## 3.确定容器中的对象拷贝正确且高效

当对vector,list,deque进行元素的插入或者删除操作时，现有的元素的位置通常会被移动（拷贝）。使用排序，反转也会被移动（拷贝）。拷贝是STL的工作方式。

当给容器中存入对象时存入的是对象的拷贝，当从容器中取出对象时，取出的容器中对象的拷贝。所以要确保拷贝的正确和高效。

当你创建的时基类对象却存着派生类对象时，拷贝就会剥离将派生的内容剥离。如果想要从基类容器使用派生类的虚方法，就要指针。

而且拷贝指针。

由于是拷贝的，因此在最后析构的时候容易出问题，因此最好采用智能指针。

## 4.调用empty判断是否为空，而不是size

首先empty一般是内联函数，而且empty的时间复杂度是常数。

size不是内联函数，而且size的时间复杂度是线性的。

## 5.区间成员函数优于与之对应单元素成员函数

给定v1和v2两个矢量，使v1的内容等于v2后半段内容相同。怎么实现。

```c++
//1.使用区间函数
v1.assign(v2.begin()+v2.size()/2,v2.end());
//2.使用copy函数，内部还是循环
v1.clear();
copy(v2.begin()+v2.size()/2,v2.end(),back_inserter(v1));
//3.使用insert,这样v1是反着的，因此每次都插到v1前面
insert(v1.begin(),v2.begin()+v2.size()/2,v2.end());
//使用单元素方法
//1.使用赋值
v1.clear()
for(vector<int>::const_iterator ci=v2.begin()+v2.size()/2;ci!=v2.end()；++ci){
    v2.push_back(ci);
}
```

从代码上

- 使用区间函数，可以少写一些代码
- 使用区间函数，意图更明确。

```c++
//将数组data内的元素添加到向量v中
//使用单元素成员函数
vector<int>::iterator insertloc(v.begin());
for(int i=0;i<numValues;i++){
	insertloc=v.insert(insertloc,data[i]);
	++insertloc;
}
```

从效率上，调用单元素成员函数

- 不必要的函数调用，将v.insert()函数调用numValues遍
- 将v中已有元素频繁的移动到插入元素的后面，每个元素移动numValues遍，如果插入元素为对象的化进行拷贝复制对象内的参数，需要的赋值次数更多。
- 如果容器为顺序存储的容器则可能会造成内存的多次扩充，则会把旧内存的元素拷贝进入新内存，并将旧内存的东西销毁然后插入新内存的东西。

对于vector 和string这三条都满足，对于deque第三条不满足。

对于list只有第一条满足，但是单个插入list会导致list需要不断变化pre 和next的指向，没有必要。